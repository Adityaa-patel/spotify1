import spotipy
import pandas as pd
import os
import time
from spotifysetup import sp  # Import the sp object
from dotenv import load_dotenv
import logging

load_dotenv()

output_file_path = 'C:\\githubb\\.venv\\spotify1\\output.csv'

# check if csv file exists if not it makes one
if not os.path.exists(output_file_path):
    df = pd.DataFrame(columns=['ts', 'ms_played', 'master_metadata_track_name',
                               'master_metadata_album_artist_name', 'master_metadata_album_album_name',
                               'spotify_track_uri', 'genre', 'reason_start', 'reason_end', 'offline_timestamp'])
    df.to_csv(output_file_path, index=False)


# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def write_entry_to_csv(entry, output_file_path):
    """Helper function to append a single entry (as a dict) to a CSV file."""
    df = pd.DataFrame([entry])
    df.to_csv(output_file_path, mode='a', header=False, index=False)

def log_currently_playing(sp, output_file_path):
    """
    Polls the current Spotify playback, logs track information, and updates the ms_played when track changes or stops.
    
    Args:
        sp: Authenticated Spotify API client.
        output_file_path: CSV file path for logging track entries.
    """
    last_track_id = None
    last_track_start_time = None
    last_track_logged = None

    try:
        while True:
            try:
                current_track = sp.current_user_playing_track()
            except Exception as e:
                logging.error(f"Error fetching current track: {e}")
                time.sleep(10)
                continue

            if current_track and current_track.get('is_playing'):
                track_item = current_track.get('item')
                if not track_item:
                    logging.warning("No track item found in response.")
                    time.sleep(10)
                    continue

                track_id = track_item.get('id')
                track_name = track_item.get('name')
                album_name = track_item.get('album', {}).get('name')
                artists = ', '.join([artist.get('name') for artist in track_item.get('artists', [])])
                # Convert timestamp from ms to datetime for logging purposes
                timestamp = pd.to_datetime(current_track['timestamp'], unit='ms')
                spotify_uri = track_item.get('uri')
                reason_start = 'unknown'
                reason_end = 'endplay'

                if track_id != last_track_id:
                    # Update ms_played for the previous track
                    if last_track_id is not None and last_track_start_time is not None:
                        ms_played = current_track['timestamp'] - last_track_start_time
                        if last_track_logged is not None:
                            last_track_logged['ms_played'] = ms_played
                            write_entry_to_csv(last_track_logged, output_file_path)
                            logging.info(f"Updated ms_played for the previous track: {ms_played} ms")

                    # Log the new track
                    new_entry = {
                        'ts': timestamp,
                        'ms_played': 0,  # Placeholder, will update on track change/stop
                        'master_metadata_track_name': track_name,
                        'master_metadata_album_artist_name': artists,
                        'master_metadata_album_album_name': album_name,
                        'spotify_track_uri': spotify_uri,
                        'reason_start': reason_start,
                        'reason_end': reason_end,
                        'offline_timestamp': 0  # Placeholder for offline timestamp
                    }
                    logging.info(f"Logged: {track_name} by {artists} at {timestamp}")

                    # Update last track variables
                    last_track_id = track_id
                    last_track_start_time = current_track['timestamp']
                    last_track_logged = new_entry

            elif last_track_id is not None:
                # Update ms_played for the last track when playback stops
                if last_track_start_time is not None:
                    ms_played = int(time.time() * 1000) - last_track_start_time
                    if last_track_logged is not None:
                        last_track_logged['ms_played'] = ms_played
                        write_entry_to_csv(last_track_logged, output_file_path)
                        logging.info(f"Updated ms_played for the previous track: {ms_played} ms")
                # Reset last track variables
                last_track_id = None
                last_track_start_time = None
                last_track_logged = None
                logging.info("Playback stopped or track skipped.")

            else:
                logging.info("No track is currently playing.")

            time.sleep(10)  # Poll every 10 seconds
    except KeyboardInterrupt:
        logging.info("Exiting log_currently_playing due to keyboard interrupt.")

output_file_path = "________________.csv"
log_currently_playing(sp, output_file_path)


# def log_currently_playing():
#     last_track_id = None
#     last_track_start_time = None
#     last_track_logged = None

#     while True:
#         # Fetch currently playing track
#         current_track = sp.current_user_playing_track()

#         if current_track is not None and current_track['is_playing']:
#             track_id = current_track['item']['id']
#             track_name = current_track['item']['name']
#             album_name = current_track['item']['album']['name']
#             artists = ', '.join([artist['name'] for artist in current_track['item']['artists']])
#             timestamp = pd.to_datetime(current_track['timestamp'], unit='ms')
#             spotify_uri = current_track['item']['uri']
#             reason_start = 'unknown'
#             reason_end = 'endplay'

#             if track_id != last_track_id:
#                 # Calculate and update ms_played for the previous track
#                 if last_track_id is not None and last_track_start_time is not None:
#                     ms_played = current_track['timestamp'] - last_track_start_time
#                     # Update the previous entry in the CSV with ms_played
#                     if last_track_logged is not None:
#                         last_track_logged['ms_played'] = ms_played
#                         df = pd.DataFrame([last_track_logged])
#                         df.to_csv(output_file_path, mode='a', header=False, index=False)
#                         print(f"Updated ms_played for the previous track: {ms_played} ms")

#                 # Log the new track
#                 new_entry = {
#                     'ts': timestamp,
#                     'ms_played': 0,  # Placeholder, updated when track changes or stops
#                     'master_metadata_track_name': track_name,
#                     'master_metadata_album_artist_name': artists,
#                     'master_metadata_album_album_name': album_name,
#                     'spotify_track_uri': spotify_uri,
#                     'reason_start': reason_start,
#                     'reason_end': reason_end,
#                     'offline_timestamp': 0  # Placeholder for offline timestamp
#                 }

#                 print(f"Logged: {track_name} by {artists} at {timestamp}")

#                 # Update last track variables
#                 last_track_id = track_id
#                 last_track_start_time = current_track['timestamp']
#                 last_track_logged = new_entry

#         elif last_track_id is not None:
#             # Calculate and update ms_played for the last track when playback stops
#             if last_track_start_time is not None:
#                 ms_played = int(time.time() * 1000) - last_track_start_time
#                 if last_track_logged is not None:
#                     last_track_logged['ms_played'] = ms_played
#                     df = pd.DataFrame([last_track_logged])
#                     df.to_csv(output_file_path, mode='a', header=False, index=False)
#                     print(f"Updated ms_played for the previous track: {ms_played} ms")
#             last_track_id = None
#             last_track_start_time = None
#             last_track_logged = None
#             print("Playback stopped or track skipped.")

#         else:
#             print("No track is currently playing.")

#         time.sleep(10)  # Check every 10 seconds
# # log_currently_playing()
'''current track contains a dictionary which has timestamp,context,progress_ms,item,currently_playing_type,actions,is_playing,items 
 items is most use full one which itself has alot of stuff same for other things few items are a list for sum reason disctionary insde a list with single item'''

def getSongName():
    current_track = sp.current_user_playing_track()
    if current_track is not None:
        return current_track['item']['name'] + " by " + current_track['item']['artists'][0]['name'] + " from album " + current_track['item']['album']['name']
    else:
        return None
    



#print(current_track['item']['artists']) # there is a dictionary which has multiple stuff, item has all we need it has artists which is of type list and then the list only has 1 element which is of type dict with info about artist, but when multoplw artist it'll have multiple elements
# print(get_artist_genres(current_track['item']['artists'][0]['name']))

# def get_artist_genres(artist_name):
#     try:
#         results = sp.search(q=f'artist:{artist_name}', type='artist', limit=1)
#         if results['artists']['items']:
#             return results['artists']['items'][0]['genres']
#         else:
#             return None
#     except Exception as e:
#         print(f"Error fetching genres for {artist_name}: {e}")
#         return None


#
#
#NOTHING WORKS 
#
#
#

def get_artist_name_list():
    current_track = sp.current_user_playing_track()
    return list(lambda x: current_track['item']['artists'][x]['name'] )

# def get_artist_genres_when_multiple(song_name):
#     try:
#         for i in song_name:
#             print(i['name'])
#     #         results = sp.search(q=f'artist:{i['name']}', type='artist', limit=1)
#     #         if results['artists']['items']:
#     #             return results['artists']['items'][0]['genres']
#     #         else:
#     #             return None
#     except Exception as e:
#         print(f"Error fetching genres for {song_name}: {e}")
#         return None
# print('kkkkk')
#print(get_artist_name_list())